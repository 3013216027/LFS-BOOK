<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-toolchaintechnotes">
  <?dbhtml filename="toolchaintechnotes.html"?>

  <title>工具链技术备注</title>

  <para>本节内容解释总体构建方法中的某些基本原理和技术细节，并不需要立即理解本节中的所有问题。
      在进行实际构建的过程中，绝大部分的信息将会变得越加清晰。在该过程中可以随时回过头来查阅本节内容。</para>

  <para><xref linkend="chapter-temporary-tools"/> 的总体目标是生成一个临时的系统，
      它包含一个已知的较好的工具集，该工具集可以与宿主系统分离。通过使用 <command>chroot</command>，
      其余各章节中的命令都包含在此环境中，以保证目标 LFS 系统能够洁净且无故障地生成。
      该构建过程的设计目标是让读者承担的风险最小，同时还能有最好的指导价值。</para>

  <note>
    <para>在继续之前，请留意工作平台的名称，它通常称作“目标系统三段式名称”。
        此名称可以通过运行 <command>config.guess</command> 命令轻松获得，许多软件的源码包都附带有该脚本
        （译者注：“目标系统三段式名称”描述了代码运行的平台，是 GUN 构建系统中一个核型概念，形如 i686-pc-gnu-linux。
        它包含三个字段：CPU 家族/型号的名称[如i686]，供应商[如pc]和操作系统名称[如gnu-linux]。
        更详细的资料请参阅 <uri>http://wiki.osdev.org/Target_Triplet</uri>）。
        解压 Binutils 源码，执行其中的 <userinput>./config.guess</userinput> 脚本，并查看其输出。
        例如：对于一个现代的 32 位英特尔处理器，其输出很可能为 <emphasis>i686-pc-gnu-linux</emphasis>。</para>

    <para>还请留意平台的动态链接器的名称，它通常被称作动态加载器
        （不要与 Binutils 中的表尊链接器 <command>ld</command> 混淆）。该同台链接器由 Glibc提供，
        它寻找并加载程序所需的共享库，为程序的运行作准备，然后运行它。对于 32 位的英特尔的机器，
        动态链接器的名称为 <filename class="libraryfile">ld-linux.so.2</filename>。
        判断动态链接器的可靠方法是检查宿主系统中的任意一个二进制文件，
        执行：<userinput>readelf -l &lt;name of binary&gt; | grep interpreter</userinput>
        且查看其输出。可在 Glibc 源码树的根目录下的 <filename>shlib-versions</filename> 文件中找到所有平台的权威参考。</para>
  </note>

  <para>下面是 <xref
  linkend="chapter-temporary-tools"/> 构建方法的几个关键技术点：</para>

  <itemizedlist>
    <listitem>
      <para>通过改变 <envar>LFS_TGT</envar> 变量的目标系统三段式中 &quot;vendor&quot; 字段，
          从而稍微调整工作平台的名称，以保证第一遍构建 Binutils 和 GCC 时能够生成兼容的交叉链接器和交叉编译器。
          此处的交叉链接器和交叉编译器生成的二进制文件与当前的硬件兼容，而不是用于其它的硬件架构。</para>
    </listitem>
    <listitem>
      <para>临时库经交叉编译获得。由于交叉编译原本就不应该依赖于宿主系统。
          因此，通过降低宿主系统的头文件或库进入新工具的可能性，该方法可去除目标系统的可能污染。
          交叉编译的方式，还可以在 64 位硬件平台上同时构建出 32 位和 64 位库。</para>
    </listitem>
    <listitem>
    <para>谨慎操作 GCC 源码，以告诉编译器将使用哪个目标系统动态链接器。</para>
    </listitem>
  </itemizedlist>

  <para>Binutils 是首个安装的包，这是因为执行 GCC 和 Glibc 的 <command>configure</command>
      命令时，都将进行有关汇编器和链接器的多项特性测试，以判断允许或禁用哪些软件特性。
      其重要性可能更甚于最初的意识。对 GCC 或 Glibc 的错误配置可能导致工具链出现难以捉摸的问题，
      可能直到整个构建过程接近尾声时才会显现出这些问题。通常情况下，
      套件测试失败可在你已经进行大量其它工作前暴露出该错误。</para>

  <para>Binutils 将其汇编器和链接器安装在两个位置，
      即 <filename class="directory">/tools/bin</filename> 和
      <filename class="directory">/tools/$LFS_TGT/bin</filename>。
      其中一个位置的工具是到另一个位置的硬链接。链接器的一个重要方面是它的库搜索顺序。
      可给 <command>ld</command> 传递 <parameter>--verbose</parameter> 参数获得详细信息。
      如 <userinput>ld --verbose | grep SEARCH</userinput> 可以得到当前的搜索路径及其顺序。
      通过编译一个模拟程序并向链接器传递 <parameter>--verbose</parameter> 开关，
      可显示 <command>ld</command> 命令都链接了哪些文件。
      例如，<userinput>gcc dummy.c -Wl,--verbose 2&gt;&amp;1 | grep succeeded</userinput>
      将将显示链接过程中成功打开的所有文件。</para>

  <para>下一个安装的包是 GCC。下面是运行 GCC 的 <command>configure</command> 时输出的示例：</para>

<screen><computeroutput>checking what assembler to use... /tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /tools/i686-lfs-linux-gnu/bin/ld</computeroutput></screen>

  <para>基于前述原因，这很重要。它还说明了 GCC 的配置脚本并不会搜索 PATH 目录来寻找使用什么工具。
      不过，在 <command>gcc</command> 自身的实际运行中，并不需要使用同样的搜索路径。
      运行 <userinput>gcc -print-prog-name=ld</userinput> 可以知道
      <command>gcc</command> 使用是何种标准链接器（译者注：<userinput>gcc -print-prog-name=ld</userinput>）。
  itself, the same search paths are not necessarily used. To find out which
  standard linker <command>gcc</command> will use, run:
  <userinput>gcc -print-prog-name=ld</userinput>.</para>

  <para>Detailed information can be obtained from <command>gcc</command> by
  passing it the <parameter>-v</parameter> command line option while compiling
  a dummy program. For example, <userinput>gcc -v dummy.c</userinput> will show
  detailed information about the preprocessor, compilation, and assembly stages,
  including <command>gcc</command>'s included search paths and their order.</para>

  <para>Next installed are sanitized Linux API headers. These allow the standard
  C library (Glibc) to interface with features that the Linux kernel will
  provide.</para>

  <para>The next package installed is Glibc. The most important considerations
  for building Glibc are the compiler, binary tools, and kernel headers. The
  compiler is generally not an issue since Glibc will always use the compiler
  relating to the <parameter>--host</parameter> parameter passed to its
  configure script, e.g. in our case,
  <command>i686-lfs-linux-gnu-gcc</command>. The binary tools and kernel
  headers can be a bit more complicated. Therefore, take no risks and use the
  available configure switches to enforce the correct selections. After the run
  of <command>configure</command>, check the contents of the
  <filename>config.make</filename> file in the <filename
  class="directory">glibc-build</filename> directory for all important details.
  Note the use of <parameter>CC="i686-lfs-gnu-gcc"</parameter> to control which
  binary tools are used and the use of the <parameter>-nostdinc</parameter> and
  <parameter>-isystem</parameter> flags to control the compiler's include
  search path. These items highlight an important aspect of the Glibc
  package&mdash;it is very self-sufficient in terms of its build machinery and
  generally does not rely on toolchain defaults.</para>

  <para>During the second pass of Binutils, we are able to utilize the
  <parameter>--with-lib-path</parameter> configure switch to control
  <command>ld</command>'s library search path.</para>

  <para>For the second pass of GCC, its sources also need to be modified to
  tell GCC to use the new dynamic linker. Failure to do so will result in the
  GCC programs themselves having the name of the dynamic linker from the host
  system's <filename class="directory">/lib</filename> directory embedded into
  them, which would defeat the goal of getting away from the host. From this
  point onwards, the core toolchain is self-contained and self-hosted. The
  remainder of the <xref linkend="chapter-temporary-tools"/> packages all build
  against the new Glibc in <filename
  class="directory">/tools</filename>.</para>

  <para>Upon entering the chroot environment in <xref
  linkend="chapter-building-system"/>, the first major package to be
  installed is Glibc, due to its self-sufficient nature mentioned above.
  Once this Glibc is installed into <filename
  class="directory">/usr</filename>, we will perform a quick changeover of the
  toolchain defaults, and then proceed in building the rest of the target
  LFS system.</para>

</sect1>
